var documenterSearchIndex = {"docs":
[{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = WhereTraits\n\nDocTestSetup = quote\n    WhereTraits.BasicTraits.@overwrite_Base\nend","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#WhereTraits","page":"Library","title":"WhereTraits","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"@traits\n@traits_show_implementation\n@traits_test","category":"page"},{"location":"library/#WhereTraits.Syntax.@traits","page":"Library","title":"WhereTraits.Syntax.@traits","text":"@traits f(a, b) where {!isempty(a), !isempty(b)} = (a[1], b[1])\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.ExtraHelpers.@traits_show_implementation","page":"Library","title":"WhereTraits.ExtraHelpers.@traits_show_implementation","text":"@traits_show_implementation mytraitsenabled_function\n\nRender a whole TraitsStore. To get an easy fealing of what is going on and inspect errors.\n\nFor debugging purposes only.\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.ExtraHelpers.@traits_test","page":"Library","title":"WhereTraits.ExtraHelpers.@traits_test","text":"like @traits, and works within Test.@testset, but cannot be doc-stringed\n\nneeded because of https://github.com/JuliaLang/julia/issues/34263\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.BasicTraits","page":"Library","title":"WhereTraits.BasicTraits","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"WhereTraits.BasicTraits.@overwrite_Base\nWhereTraits.BasicTraits.iscallable\nWhereTraits.BasicTraits.isiterable\nWhereTraits.BasicTraits.isimmutable\nWhereTraits.BasicTraits.ismutable\nWhereTraits.BasicTraits.isconcretetype\nWhereTraits.BasicTraits.isbitstype","category":"page"},{"location":"library/#WhereTraits.BasicTraits.@overwrite_Base","page":"Library","title":"WhereTraits.BasicTraits.@overwrite_Base","text":"WhereTraits.BasicTraits.@overwrite_Base\n\nOverloading functions already defined in base, so that they work similar to Base.eltype in that they are best defined on Types, with a fallback from values which just grabs the type of the value and tries it again.\n\nThe following functions are currently over-defined:\n\nisimmutable\nismutable\nisbitstype\nisconcretetype\n\nIn addition, also using WhereTraits.BasicTraits is run.\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.BasicTraits.iscallable","page":"Library","title":"WhereTraits.BasicTraits.iscallable","text":"callable(T) -> Bool\n\nChecks whether the call-syntax is defined for the given Type. For convenience iscallable(value) = iscallable(typeof(value))\n\nExamples\n\njulia> iscallable(typeof(+))\ntrue\n\njulia> iscallable(+)\ntrue\n\njulia> iscallable(Some)\nfalse\n\njulia> iscallable(typeof(Some))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isiterable","page":"Library","title":"WhereTraits.BasicTraits.isiterable","text":"isiterable(T) -> Bool\n\nTest if type T is an iterable collection type or not, that is whether it has an iterate method or not.\n\nWhen given a value instead of a Type, it fallbacks to use typeof(value).\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isimmutable","page":"Library","title":"WhereTraits.BasicTraits.isimmutable","text":"isimmutable(v) -> Bool\n\nReturn true iff value v is immutable.  See Mutable Composite Types for a discussion of immutability. Note that this function works on Types instead of values (oppositely to Base.isimmutable). When applied to a value, a default clause will match on its type instead.\n\nExamples\n\njulia> isimmutable(1)\ntrue\n\njulia> isimmutable([1,2])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.ismutable","page":"Library","title":"WhereTraits.BasicTraits.ismutable","text":"ismutable(v) -> Bool\n\nReturn true iff value v is mutable.  See Mutable Composite Types for a discussion of mutability. Note that this function works on Types instead of values (oppositely to Base.isimmutable). When applied to a value, a default clause will match on its type instead.\n\nExamples\n\njulia> ismutable(1)\nfalse\n\njulia> ismutable([1,2])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isconcretetype","page":"Library","title":"WhereTraits.BasicTraits.isconcretetype","text":"isconcretetype(T)\n\nDetermine whether type T is a concrete type, meaning it could have direct instances (values x such that typeof(x) === T).\n\nFor convenience isconcretetype(value) = isconcretetype(typeof(value))\n\nExamples\n\njulia> isconcretetype(Complex)\nfalse\n\njulia> isconcretetype(Complex{Float32})\ntrue\n\njulia> isconcretetype(Vector{Complex})\ntrue\n\njulia> isconcretetype(Vector{Complex{Float32}})\ntrue\n\njulia> isconcretetype(Union{})\nfalse\n\njulia> isconcretetype(Union{Int,String})\nfalse\n\njulia> isconcretetype([1,2,3])\ntrue\n\njulia> isconcretetype(\"hi\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isbitstype","page":"Library","title":"WhereTraits.BasicTraits.isbitstype","text":"isbitstype(T)\n\nReturn true if type T is a \"plain data\" type, meaning it is immutable and contains no references to other values, only primitive types and other isbitstype types. Typical examples are numeric types such as UInt8, Float64, and Complex{Float64}. This category of types is significant since they are valid as type parameters, may not track isdefined / isassigned status, and have a defined layout that is compatible with C.\n\nFor convenience isbitstype(value) = isbitstype(typeof(value))\n\nExamples\n\njulia> isbitstype(Complex{Float64})\ntrue\n\njulia> isbitstype(Complex)\nfalse\n\njulia> isbitstype(1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"DocTestSetup = nothing","category":"page"},{"location":"manual/#Manual","page":"@traits","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"@traits","title":"@traits","text":"Welcome to WhereTraits.jl. This package exports one powerful macro @traits with which you can extend Julia's where syntax. Concretely the following are supported:","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"dispatch on functions returning Bool","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"@traits f(a) where {isodd(a)} = (a+1)/2\n@traits f(a) where {!isodd(a)} = a/2\nf(4) # 2.0\nf(5) # 3.0","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"dispatch on functions returning anything","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"@traits g(a) where {Base.IteratorSize(a)::Base.HasShape} = 43\n@traits g(a) = 1\ng([1,2,3]) # 43\ng(Iterators.repeated(1)) # 1","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"dispatch on bounds on functions returning Types","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"@traits h(a) where {eltype(a) <: Number} = true\n@traits h(a) = false\nh([1.0]) # true\nh([\"\"]) # false","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"And all this works with arbitrary many where expressions and creates optimal code where possible via standard Julia compiler.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Warning: While the dispatch works for dynamic functions, it will only be able to create optimal code if your traits function supports proper type-inference. E.g. you can use Base.isempty, however type-inference cannot see whether it will return true or false by static inspection. Hence it will use slower dynamic code.","category":"page"},{"location":"manual/#Installation","page":"@traits","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"@traits","title":"@traits","text":"The package is soon going to be registered at General, until then you can use it by adding a custom registry.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"using Pkg\npkg\"registry add https://github.com/JuliaRegistries/General\"  # central julia registry\npkg\"registry add https://github.com/schlichtanders/SchlichtandersJuliaRegistry.jl\"  # custom registry\npkg\"add WhereTraits\"","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Use it like","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"using WhereTraits","category":"page"},{"location":"manual/#Auto-Documentation","page":"@traits","title":"Auto Documentation","text":"","category":"section"},{"location":"manual/","page":"@traits","title":"@traits","text":"The package supports advanced auto-documentation which gives you a good overview about what is defined in a @traits function.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"help?> h\n\n  h(a1::T1; kwargs...) where T1\n\n  ––– Original @traits definitions follow –––\n\n  h(a) where eltype(a) <: Number\n\n  Original @traits definition:\n\n  (h(a) where eltype(a) <: Number) = begin\n          #= none:1 =#\n          true\n      end\n\n    •      •      •  \n\n  h(a)\n\n  Original @traits definition:\n\n  h(a) = begin\n          #= none:1 =#\n          false\n      end","category":"page"},{"location":"manual/#Implementation-Details","page":"@traits","title":"Implementation Details","text":"","category":"section"},{"location":"manual/","page":"@traits","title":"@traits","text":"The implementations uses only code-rewrite, creating two nested functions out of the one @traits function. The outer function dispatches as normal, the inner function dispatches on the added traits functionality.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"To inspect what is going on it is helpful to turn off the auto_documentation feature by setting","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"WhereTraits.CONFIG.auto_documentation = false","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"After this the macroexpand is simpler to understand","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"@macroexpand @traits foo(a) where {isodd(a)} = (a+1)/2","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"which gives the following code","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"function foo(a1::T1; kwargs...) where T1\n    #= none:1 =#\n    (Main).foo(\n      WhereTraits.InternalState.TraitsSingleton(),\n      Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any},\n      a1,\n      WhereTraits.Syntax.Rendering._BetweenArgsAndTypeVars(),\n      T1,\n      WhereTraits.Syntax.Rendering._BetweenTypeVarsAndTraits(),\n      Val{isodd(a1)}();\n      kwargs...)\nend\n\nfunction foo(::WhereTraits.InternalState.TraitsSingleton,\n             ::Type{Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}},\n             a,\n             ::WhereTraits.Syntax.Rendering._BetweenArgsAndTypeVars,\n             var\"'T1'\"::Any,\n             ::WhereTraits.Syntax.Rendering._BetweenTypeVarsAndTraits,\n             var\"'Val{isodd(a1)}()'\"::Val{true})\n    #= none:1 =#\n    (a + 1) / 2\nend\n\nfunction foo(::WhereTraits.InternalState.TraitsSingleton)\n    #= /Users/s.sahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:111 =#\n    WhereTraits.InternalState.TraitsStore(WhereTraits.InternalState.Reference(Main, :foo), WhereTraits.Utils.TypeDict{WhereTraits.InternalState.DefTraitsFunction}(Tuple{Type,WhereTraits.InternalState.DefTraitsFunction}[(Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}, WhereTraits.InternalState.DefTraitsFunction{Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}}(WhereTraits.InternalState.DefOuterFunc{Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}}(WhereTraits.InternalState.DefOuterFuncFixedPart{Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}}(Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}, :foo, Union{Expr, Symbol}[], ExprParsers.Arg_Parsed[EP.Arg_Parsed(name=:a1, type=:T1, default=ExprParsers.NoDefault())], ExprParsers.TypeRange_Parsed[EP.TypeRange_Parsed(lb=Union{}, name=:T1, ub=Any)], Symbol[:a1], Symbol[:T1]), WhereTraits.InternalState.DefOuterFuncNonFixedPart(Union{Expr, Symbol}[:(Val{isodd(a1)}())])), Dict(WhereTraits.InternalState.DefInnerFuncFixedPart(Dict(:a1 => :a), Dict{Symbol,Symbol}(), Dict{Union{Expr, Symbol},Union{Expr, Symbol}}(:(Val{isodd(a1)}()) => :(var\"'Val{isodd(a1)}()'\"::Val{true}))) => WhereTraits.InternalState.DefInnerFuncNonFixedPart(Expr[], quote\n#= none:1 =#\n(a + 1) / 2\nend, :((foo(a) where isodd(a)) = begin\n      #= none:1 =#\n      (a + 1) / 2\n  end)))))]))\nend\nnothing","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"It is actually easy to understand on a high level:","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"The first function function foo(a1::T1; kwargs...) where T1 is the so called \"outer\" function which does all the normal standard Julia dispatch. It is the necessary initial entry point in order to then perform a subsequent call to further dispatch on traits.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"In the function body you see that this outer function extracts extra information according to the extended where-syntax. Lets go through the arguments one by one","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"WhereTraits.InternalState.TraitsSingleton() is a helper type indicating that this is a call to a traits inner function\nTuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any} is the complete function signature of the outer function, with an additional helper _BetweenCurliesAndArgs to deal with TypeParameters of UnionAll types (whereupon which you can also define function calls and hence @traits)\na1 is the first actual argument (after this a2, a3 and etc. could follow in principle)\nWhereTraits.Syntax.Rendering._BetweenArgsAndTypeVars() is again a helper type to distinguish args from typevariables\nT1 is a type parameter (again here T2, T3, etc. would follow if there are more typeparameters)\nWhereTraits.Syntax.Rendering._BetweenTypeVarsAndTraits() is another helper, now separating the traits definitions\nVal{isodd(a1)}() here comes our first actual trait definition (if you define more traits, they would follow here)\n; kwargs... at last all kwargs are just passed through (dispatch on kwargs is not yet supported)","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"All these arguments are passed on to the inner function, which is defined next.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"The second function is this inner function function foo(::WhereTraits.InternalState.TraitsSingleton, ::Type{Tuple{WhereTraits.Syntax._BetweenCurliesAndArgs,Any}}, a, ::WhereTraits.Syntax._BetweenArgsAndTypeVars, var\"'T1'\"::Any, ::WhereTraits.Syntax._BetweenTypeVarsAndTraits, var\"'Val{isodd(a1)}()'\"::Val{true}).","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Here we do the actual full traits dispatch, specifying a dispatch type for each of the arguments we just put into the inner functions. Let's again go through each single argument:","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"::WhereTraits.InternalState.TraitsSingleton dispatches on the singleton type to make sure this does not conflict with any other methods defined for this function\n::Type{Tuple{WhereTraits.Syntax._BetweenCurliesAndArgs,Any}} dispatches on the signature of the outer function, again adding support for types with Type-parameters which is why you see this extra type WhereTraits.Syntax._BetweenCurliesAndArgs. If you would have dispatch for say function MyType{Int, Bool}(a::Any, b::Any) this would look like ::Type{Tuple{Int, Bool, WhereTraits.Syntax._BetweenCurliesAndArgs,Any, Any}} respectively\na is just the standard argument, which was of type Any.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Hereafter, other arguments would follow.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"::WhereTraits.Syntax._BetweenArgsAndTypeVars is again a helper for dispatch separation\nvar\"'T1'\"::Any corresponds to the normal standard TypeParameter, here of type Any.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"It was renamed into `var\"'T1'\"`, because it is actually nowhere used in the function body. If you would have used the TypeVariable `T1`, it is named plainly `T1`.\nThis was implemented because the syntax actually may have to add extra typeparameters, which then for sure are not used by the code. Hence we distinguish used/unused typeparameters for better debugging/inspecting.\n\nHereafter, other standard type parameters would follow.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"::WhereTraits.Syntax._BetweenTypeVarsAndTraits is the last helper for dispatch separation\nvar\"'Val{isodd(a1)}()'\"::Val{true}) is our extended where-dispatch for Bool function\nYou see that the syntax automatically wrapped the function into a Val and here we dispatch on Val{true}. The name is extra descriptive and refers to the precise function call which happens in the outer function. This can be helpful for debugging and inspecting.\nThis function does not define any keyword arguments.\nThe last complex looking function is function foo(::WhereTraits.InternalState.TraitsSingleton). It again uses the TraitsSingleton to indicate that this is an internal detail of the traits syntax, however does not take any further arguments. Concretely, it defines the hidden state which is needed to correctly construct the outer and inner functions required to realise the extended dispatch of @traits. You don't have to understand it, still you hopefully get the feeling that everything is there.\nFinally there is nothing in order to prevent printing possibly confusing internal details.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"If you try @macroexpand @traits foo(a) where {!isodd(a)} = a/2 instead, you will see that it is very similar, but dispatching on ::Val{false} instead. This is part of the special support for bool function.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Also try @macroexpand @traits foo(a) where {iseven(a)} = a/2 and see what the syntax does differently.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Now execute","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"@traits foo(a) where {isodd(a)} = (a+1)/2","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"and repeat inspecting @macroexpand @traits foo(a) where {!isodd(a)} = a/2 vs @macroexpand @traits foo(a) where {iseven(a)} = a/2.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Also try inspecting methods with other outerfunctions, like @macroexpand @traits foo(a, b) = a + b. You will start appreciating the hidden complexity behind the @traits syntax.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"While the syntax mapping to an outerfunction and respective innerfunctions feels very intuitive, the needed implementation is surprisingly complicated. Luckily, all this is encapsulated nicely in the @traits macro. Enjoy!","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"If you ever are curious what the whole implementation of your @traits function is, there is a helper macro @traits_show_implementation. For instance if you finally defined","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"@traits foo(a) where {isodd(a)} = (a+1)/2\n@traits foo(a) where {!isodd(a)} = a/2","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"@traits_show_implementation will give you the full implementation, omitting the internal state.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"julia> @traits_show_implementation foo\n  Outer function for signature Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}\n\n  function foo(a1::T1; kwargs...) where T1\n      #= none:1 =#\n      (Main).foo(WhereTraits.InternalState.TraitsSingleton(), Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}, a1, WhereTraits.Syntax.Rendering._BetweenArgsAndTypeVars(), T1, WhereTraits.Syntax.Rendering._BetweenTypeVarsAndTraits(), Val{isodd(a1)}(); kwargs...)\n  end)\n\n    •      •      •  \n\n  Inner functions for signature Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}\n\n  function foo(::WhereTraits.InternalState.TraitsSingleton, ::Type{Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}}, a, ::WhereTraits.Syntax.Rendering._BetweenArgsAndTypeVars, var\"'T1'\"::Any, ::WhereTraits.Syntax.Rendering._BetweenTypeVarsAndTraits, var\"'Val{isodd(a1)}()'\"::Val{true})\n      #= none:1 =#\n      (a + 1) / 2\n  end\n\n    •      •      •  \n\n  function foo(::WhereTraits.InternalState.TraitsSingleton, ::Type{Tuple{WhereTraits.Syntax.Parsing._BetweenCurliesAndArgs,Any}}, a, ::WhereTraits.Syntax.Rendering._BetweenArgsAndTypeVars, var\"'T1'\"::Any, ::WhereTraits.Syntax.Rendering._BetweenTypeVarsAndTraits, var\"'Val{isodd(a1)}()'\"::Val{false})\n      #= none:1 =#\n      a / 2\n  end\n\n    •      •      •  \n\n  ────────────────────────────────────────────────────────────────","category":"page"},{"location":"manual/#Performance-Comparison-with-[mauro3/SimpleTraits.jl](https://github.com/mauro3/SimpleTraits.jl)","page":"@traits","title":"Performance + Comparison with mauro3/SimpleTraits.jl","text":"","category":"section"},{"location":"manual/","page":"@traits","title":"@traits","text":"For a high-level comparison between WhereTraits.@traits and SimpleTraits.jl see the respective discourse discussion.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"The following examples mirror https://github.com/mauro3/SimpleTraits.jl#details-of-method-dispatch. We start with defining a custom function fn, a custom Trait function isTr and some methods for fn dispatching on the trait.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"isTr(_) = false\n\nfn(x::Integer) = 1\n@traits fn(x::X) where {X<:AbstractFloat, isTr(X)} = 2\n@traits fn(x::AbstractFloat) = 3\n\nfn(Float32(5)) # 3; dispatch through traits, but isTr not yet defined, hence using default case\n\nisTr(::Type{Float32}) = true\nisTr(::Type{Int}) = true\n\nfn(5) # 1; dispatch only happens on the type\nfn(Float32(5)) # 2; dispatch through traits\nfn(Float64(5)) # 3; default dispatch through traits\n\n\nisTr2(_) = false\nisTr2(::Type{Float16}) = true\n@traits fn(x::X) where {X <: AbstractFloat, isTr2(X)} = 4\n\nfn(Float16(5)) # 4; dispatch through traits\nfn(Float32(5)) # 2; NO MethodError; nothing is overwritten, everything works like you would hope for","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"Finally the performance test: Julia is indeed inferring the very same native code.","category":"page"},{"location":"manual/","page":"@traits","title":"@traits","text":"julia> @code_native fn(5)\n    .section    __TEXT,__text,regular,pure_instructions\n; ┌ @ none:1 within `fn'\n    movl    $1, %eax\n    retq\n    nopw    %cs:(%rax,%rax)\n; └\njulia> @code_native fn(Float16(5))\n    .section    __TEXT,__text,regular,pure_instructions\n; ┌ @ none:1 within `fn'\n    movl    $4, %eax\n    retq\n    nopw    %cs:(%rax,%rax)\n; └","category":"page"},{"location":"basictraits/#WhereTraits.BasicTraits","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"","category":"section"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"For anology with SimpleTraits.jl, this package comes with standard traits definitions ismutable, isimmutable, isiterable, iscallable, isbitstype, isconcretetype. They mostly just wrap respective standard definitions in Base, with the added benefit, that they behave similarly to Base.eltype in that they have the convenience fallback ismutable(value) = ismutable(typeof(value)).","category":"page"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"You can use them by executing the following","category":"page"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"using WhereTraits\nusing WhereTraits.BasicTraits\nWhereTraits.BasicTraits.@overwrite_Base\n\nismutable(1)  # false\nismutable(\"string\")  # true\nismutable(String)  # true","category":"page"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"Please consult the file test/BasicTraits.jl for more examples.","category":"page"},{"location":"#WhereTraits.jl","page":"Home","title":"WhereTraits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to WhereTraits.jl. This package exports one powerful macro @traits with which you can extend Julia's where syntax. Concretely the following are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"dispatch on functions returning Bool","category":"page"},{"location":"","page":"Home","title":"Home","text":"@traits f(a) where {isodd(a)} = (a+1)/2\n@traits f(a) where {!isodd(a)} = a/2\nf(4) # 2.0\nf(5) # 3.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"dispatch on functions returning anything","category":"page"},{"location":"","page":"Home","title":"Home","text":"@traits g(a) where {Base.IteratorSize(a)::Base.HasShape} = 43\n@traits g(a) = 1\ng([1,2,3]) # 43\ng(Iterators.repeated(1)) # 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"dispatch on bounds on functions returning Types","category":"page"},{"location":"","page":"Home","title":"Home","text":"@traits h(a) where {eltype(a) <: Number} = true\n@traits h(a) = false\nh([1.0]) # true\nh([\"\"]) # false","category":"page"},{"location":"","page":"Home","title":"Home","text":"And all this works with arbitrary many where expressions and creates optimal code where possible via standard Julia compiler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Warning: While the dispatch works for dynamic functions, it will only be able to create optimal code if your traits function supports proper type-inference. E.g. you can use Base.isempty, however type-inference cannot see whether it will return true or false by static inspection. Hence it will use slower dynamic code.","category":"page"},{"location":"#Installation-and-Import","page":"Home","title":"Installation & Import","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"registry add https://github.com/JuliaRegistries/General\"  # central julia registry\npkg\"registry add https://github.com/schlichtanders/SchlichtandersJuliaRegistry.jl\"  # custom registry\npkg\"add WhereTraits\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then use this package by loading","category":"page"},{"location":"","page":"Home","title":"Home","text":"using WhereTraits","category":"page"},{"location":"","page":"Home","title":"Home","text":"which makes one macro available @traits","category":"page"},{"location":"#Current-Restrictions-and-Future-Plans","page":"Home","title":"Current Restrictions and Future Plans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently the @traits macro has some known restrictions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the extended where syntax is currently implemented on symbol level, which is why traits functions like Base.IteratorSize and the non-qualified IteratorSize (assuming you imported import Base:IteratorSize) are treated as two different functions, despite being the same. So for now try to only use the one style or the other.\nOn possibility would be to fix this by looking up method definitions in the caller module.\ncurrently only top-level functions are directly supported, as the syntax stores and needs information about previous function definitions. An alternative syntax is planned which will support @traits on functions within other scopes like functions in functions.\nThe idea I have is to support a block syntax alternative   which assumes that there is no further outer state to take into account, but the block stands on its own. This would still look a bit clumsy, but semantically it is probably the way to go.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function func()\n  @traits begin  # not yet supported\n    function nested(a) where ...\n    end\n    function nested(a) where ...\n    end\n  end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @traits currently does not work well within the Test.@testset macro. As a workaround WhereTraits.jl exports a @traits_test variant which works better, but still has cases where it fails. This needs to be investigated further, and maybe needs a fix on Test.@testset, don't know.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"},{"location":"isdef/#Dispatch-on-whether-functions-are-defined-using-[IsDef.jl](https://github.com/schlichtanders/IsDef.jl)","page":"Combination with isdef","title":"Dispatch on whether functions are defined - using IsDef.jl","text":"","category":"section"},{"location":"isdef/","page":"Combination with isdef","title":"Combination with isdef","text":"You want to dispatch on whether a function is defined or not? I guess this is a standard scenario and hence I tried to support it, and extracted it into another package.","category":"page"},{"location":"isdef/","page":"Combination with isdef","title":"Combination with isdef","text":"IsDef.jl exports two functions isdef and Out with which you can dispatch on whether functions are defined or not. (IsDef.jl is a sub-dependency of WhereTraits.jl, so you should already have it installed). With IsDef.isdef/IsDef.Out and WhereTraits.@traits we can define typesafe dispatch like follows:","category":"page"},{"location":"isdef/","page":"Combination with isdef","title":"Combination with isdef","text":"using WhereTraits\nusing IsDef\nusing Test\n\nstruct MyError <: Exception\n  msg::AbstractString\nend\nMyError() = MyError(\"\")\n\n@traits typesafe_call(f, a::T) where {T, isdef(f, T)} = f(a)\n# note that you can also use isdef on args directly, like you can use eltype on args\n# however this will be recognized as a different traitfunction compared to isdef(f, T)\n# which can lead to ambiguous overloadings. Just good to keep in mind\n@traits typesafe_call(f, a) where {!isdef(f, a)} = throw(MyError(\"given function cannot work with given arg\"))\n@code_llvm typesafe_call(x -> x+2, 4)  # looks really good\n\n@test typesafe_call(x -> x+2, 4) == 6\n@test_throws MyError typesafe_call(x -> x+2, \"string\")\n\n\n@traits typesafe_out(f, a) where {Out(f, a) <: Number} = f(a) + 6\n@traits typesafe_out(f, a) where {Out(f, a) <: String} = \"yeah $(f(a))!\"\n@traits typesafe_out(f, a) = throw(MyError(\"no match\"))\n\n@test typesafe_out(x -> 3x, 1) == 9\n@test typesafe_out(x -> \"$x $x\", 1) == \"yeah 1 1!\"\n@test_throws MyError typesafe_out(x -> convert(Vector, x), 1)\n\n\n# more complex case with dependencies among functions\n@traits function typesafe_aggregate(a::Vector{A}, introduce, combine) where\n    {A, isdef(introduce, A), isdef(combine, Out(introduce, A), Out(introduce, A))}\n\n  reduce(combine, introduce.(a))\nend\n@traits typesafe_aggregate(a::Vector, introduce, combine) = throw(MyError(\"TypeError\"))\n\n@test typesafe_aggregate([\"this\",\"is\",\"a\",\"test\"], length, +) == 11\n@test typesafe_aggregate([\"this\",\"is\",\"a\",\"test\"], length, *) == 32\n@test typesafe_aggregate([\"this\",\"is\",\"a\",\"test\"], x -> \"$x \", *) == \"this is a test \"\n@test_throws MyError typesafe_aggregate([\"this\",\"is\",\"a\", \"test\"], x->x, +)","category":"page"},{"location":"isdef/","page":"Combination with isdef","title":"Combination with isdef","text":"This is very powerful. Be warned that IsDef has limitations currently because julia type-inference has limitations. Luckily the type-inference is already very good with concrete-types, which is what we need for dispatch.","category":"page"}]
}
