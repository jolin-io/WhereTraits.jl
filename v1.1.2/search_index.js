var documenterSearchIndex = {"docs":
[{"location":"details/#WhereTraits-Details","page":"WhereTraits Details`","title":"WhereTraits Details","text":"","category":"section"},{"location":"details/#Auto-Documentation","page":"WhereTraits Details`","title":"Auto Documentation","text":"","category":"section"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"The package supports advanced auto-documentation which gives you a good overview about what is defined in a @traits function.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Let's consider the following example","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"@traits h(a) where {eltype(a) <: Number} = true\n@traits h(a) = false\nh([1.0]) # true\nh([\"\"]) # false","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"then you get nice formatted documentation","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"help?> h\n\n  h(a1::T1; kwargs...) where T1\n\n  ––– Original @traits definitions follow –––\n\n  h(a) where eltype(a) <: Number\n\n  Original @traits definition:\n\n  (h(a) where eltype(a) <: Number) = begin\n          #= none:1 =#\n          true\n      end\n\n    •      •      •  \n\n  h(a)\n\n  Original @traits definition:\n\n  h(a) = begin\n          #= none:1 =#\n          false\n      end","category":"page"},{"location":"details/#MethodError-handling","page":"WhereTraits Details`","title":"MethodError handling","text":"","category":"section"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Like with normal function dispatch you can also get MethodErrors when using traits.  While the pure MethodError can be helpful for the experienced WhereTraits user, for most it will be rather incomprehensible. This is why WhereTraits catches MethodErrors and  rephrases them in easier to understand TraitsMethodError.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Here one example","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia> @traits myfunc(a) where {Base.IteratorSize(a)::Base.HasShape} = 2\n\njulia> myfunc([1])\n2\n\njulia> myfunc(Iterators.countfrom())\nERROR: TraitsMethodError: no method matching `myfunc(Base.Iterators.Count{Int64}(1, 1))`.\n\nIt corresponds to the normal julia-dispatch (aka \"outerfunction\")\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia myfunc(a1::T1; kwargs...) where T1","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\nand the traits (traits are normalized to <:)\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia Core.Typeof(Base.IteratorSize(a1)) <: Base.IsInfinite","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\nhowever, the only available traits definitions are:\n\n  *   *   *   *   *   *   *   *   *   *   *   *   *   *\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia myfunc(a) where Base.IteratorSize(a)::Base.HasShape","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\nwhich defines the traits (traits are normalized to <:)\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia Core.Typeof(Base.IteratorSize(a1)) <: Base.HasShape","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\n  *   *   *   *   *   *   *   *   *   *   *   *   *   *\n\nNote the following `<:` standardization of traits:\n\n|        WhereTraits |                               Example |                                   `<:` standardization |\n| ------------------:| -------------------------------------:| ------------------------------------------------------:|\n|         bool trait |                           `iseven(a)` |  `WhereTraits.BoolType(iseven(a)) <: WhereTraits.True` |\n| negated bool trait |                          `!iseven(a)` | `WhereTraits.BoolType(iseven(a)) <: WhereTraits.False` |\n|        `isa` trait | `Base.IteratorSize(a)::Base.HasShape` |   `Core.Typeof(Base.IteratorSize(a)) <: Base.HasShape` |\n|         `<:` trait |            `Base.eltype(a) <: Number` |                             `Base.eltype(a) <: Number` |\n\nStacktrace:\n [1] #myfunc#4\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:215 [inlined]\n [2] myfunc(a1::Base.Iterators.Count{Int64}; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Main ./REPL[10]:0\n [3] myfunc\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:211 [inlined]\n [4] myfunc(a1::Base.Iterators.Count{Int64})\n   @ Main ./REPL[10]:0\n [5] top-level scope\n   @ REPL[12]:1\n\ncaused by: MethodError: no method matching myfunc(::WhereTraits.InternalState.TraitsDefSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, ::Base.Iterators.Count{Int64}, ::<ARGS|TYPEVARS>, ::Type{Base.Iterators.Count{Int64}}, ::<TYPEVARS|TRAITS>, ::Type{Base.IsInfinite})┌ Error: Error showing method candidates, aborted\n│   exception =\n│    could not determine location of method definition\n│    Stacktrace:\n│      [1] error(s::String)\n│        @ Base ./error.jl:33\n│      [2] functionloc\n│        @ ./methodshow.jl:164 [inlined]\n│      [3] show_method_candidates(io::IOContext{Base.TTY}, ex::MethodError, kwargs::Any)\n│        @ Base ./errorshow.jl:499\n│      [4] showerror(io::IOContext{Base.TTY}, ex::MethodError)\n│        @ Base ./errorshow.jl:318\n│      [5] showerror(io::IOContext{Base.TTY}, ex::MethodError, bt::Vector{Base.StackTraces.StackFrame}; backtrace::Bool)\n│        @ Base ./errorshow.jl:88\n│      [6] show_exception_stack(io::IOContext{Base.TTY}, stack::Vector{Any})\n│        @ Base ./errorshow.jl:866\n│      [7] display_error(io::IOContext{Base.TTY}, stack::Base.ExceptionStack)\n│        @ Base ./client.jl:104\n│      [8] #invokelatest#2\n│        @ ./essentials.jl:716 [inlined]\n│      [9] invokelatest\n│        @ ./essentials.jl:714 [inlined]\n│     [10] print_response(errio::IO, response::Any, show_value::Bool, have_color::Bool, specialdisplay::Union{Nothing, AbstractDisplay})\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:286\n│     [11] (::REPL.var\"#45#46\"{REPL.LineEditREPL, Pair{Any, Bool}, Bool, Bool})(io::Any)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:275\n│     [12] with_repl_linfo(f::Any, repl::REPL.LineEditREPL)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:508\n│     [13] print_response(repl::REPL.AbstractREPL, response::Any, show_value::Bool, have_color::Bool)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:273\n│     [14] (::REPL.var\"#do_respond#66\"{Bool, Bool, REPL.var\"#77#87\"{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:844\n│     [15] #invokelatest#2\n│        @ ./essentials.jl:716 [inlined]\n│     [16] invokelatest\n│        @ ./essentials.jl:714 [inlined]\n│     [17] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n│        @ REPL.LineEdit /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493\n│     [18] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1230\n│     [19] (::REPL.var\"#49#54\"{REPL.LineEditREPL, REPL.REPLBackendRef})()\n│        @ REPL ./task.jl:423\n└ @ Base errorshow.jl:320\n\nStacktrace:\n [1] myfunc(::WhereTraits.InternalState.TraitsDisambiguationSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a1::Base.Iterators.Count{Int64}, ::<ARGS|TYPEVARS>, T1::Type, ::<TYPEVARS|TRAITS>, 'trait_1_Base.IteratorSize(a1)'::Type; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Main ./none:0\n [2] myfunc(::WhereTraits.InternalState.TraitsDisambiguationSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a1::Base.Iterators.Count{Int64}, ::<ARGS|TYPEVARS>, T1::Type, ::<TYPEVARS|TRAITS>, 'trait_1_Base.IteratorSize(a1)'::Type)\n   @ Main ./none:0\n [3] #myfunc#4\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:212 [inlined]\n [4] myfunc(a1::Base.Iterators.Count{Int64}; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Main ./REPL[10]:0\n [5] myfunc\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:211 [inlined]\n [6] myfunc(a1::Base.Iterators.Count{Int64})\n   @ Main ./REPL[10]:0\n [7] top-level scope\n   @ REPL[12]:1","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"The error now states clearly that the demanded trait Core.Typeof(Base.IteratorSize(a1)) <: Base.IsInfinite is not defined yet. Internally within WhereTraits all traits (bool traits, ::-traits and <:-traits) are normalized to <:-traits.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"To fix this implementation you would add a definition with the trait Base.IteratorSize(a1)::Base.IsInfinite.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"A second example is about a typo: Here the value-level :: trait is confused with the type-level <: Trait.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia> @traits myfunc2(a) where {Base.IteratorSize(a) <: Base.HasShape} = 2  # wrong!! it should be `Base.IteratorSize(a)::Base.HasShape`\n\njulia> myfunc2([1])\nERROR: TraitsMethodError: no method matching `myfunc2([1])`.\n\nIt corresponds to the normal julia-dispatch (aka \"outerfunction\")\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia myfunc2(a1::T1; kwargs...) where T1","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\nand the traits (traits are normalized to <:)\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia Base.IteratorSize(a1) <: Base.HasShape{1}()","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\nhowever, the only available traits definitions are:\n\n  *   *   *   *   *   *   *   *   *   *   *   *   *   *\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia myfunc2(a) where Base.IteratorSize(a) <: Base.HasShape","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\nwhich defines the traits (traits are normalized to <:)\n","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia Base.IteratorSize(a1) <: Base.HasShape","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"\n  *   *   *   *   *   *   *   *   *   *   *   *   *   *\n\nNote the following `<:` standardization of traits:\n\n|        WhereTraits |                               Example |                                   `<:` standardization |\n| ------------------:| -------------------------------------:| ------------------------------------------------------:|\n|         bool trait |                           `iseven(a)` |  `WhereTraits.BoolType(iseven(a)) <: WhereTraits.True` |\n| negated bool trait |                          `!iseven(a)` | `WhereTraits.BoolType(iseven(a)) <: WhereTraits.False` |\n|        `isa` trait | `Base.IteratorSize(a)::Base.HasShape` |   `Core.Typeof(Base.IteratorSize(a)) <: Base.HasShape` |\n|         `<:` trait |            `Base.eltype(a) <: Number` |                             `Base.eltype(a) <: Number` |\n\nStacktrace:\n [1] #myfunc2#6\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:215 [inlined]\n [2] myfunc2(a1::Vector{Int64}; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Main ./REPL[13]:0\n [3] myfunc2\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:211 [inlined]\n [4] myfunc2(a1::Vector{Int64})\n   @ Main ./REPL[13]:0\n [5] top-level scope\n   @ REPL[14]:1\n\ncaused by: MethodError: no method matching myfunc2(::WhereTraits.InternalState.TraitsDefSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, ::Vector{Int64}, ::<ARGS|TYPEVARS>, ::Type{Vector{Int64}}, ::<TYPEVARS|TRAITS>, ::Base.HasShape{1})┌ Error: Error showing method candidates, aborted\n│   exception =\n│    could not determine location of method definition\n│    Stacktrace:\n│      [1] error(s::String)\n│        @ Base ./error.jl:33\n│      [2] functionloc\n│        @ ./methodshow.jl:164 [inlined]\n│      [3] show_method_candidates(io::IOContext{Base.TTY}, ex::MethodError, kwargs::Any)\n│        @ Base ./errorshow.jl:499\n│      [4] showerror(io::IOContext{Base.TTY}, ex::MethodError)\n│        @ Base ./errorshow.jl:318\n│      [5] showerror(io::IOContext{Base.TTY}, ex::MethodError, bt::Vector{Base.StackTraces.StackFrame}; backtrace::Bool)\n│        @ Base ./errorshow.jl:88\n│      [6] show_exception_stack(io::IOContext{Base.TTY}, stack::Vector{Any})\n│        @ Base ./errorshow.jl:866\n│      [7] display_error(io::IOContext{Base.TTY}, stack::Base.ExceptionStack)\n│        @ Base ./client.jl:104\n│      [8] #invokelatest#2\n│        @ ./essentials.jl:716 [inlined]\n│      [9] invokelatest\n│        @ ./essentials.jl:714 [inlined]\n│     [10] print_response(errio::IO, response::Any, show_value::Bool, have_color::Bool, specialdisplay::Union{Nothing, AbstractDisplay})\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:286\n│     [11] (::REPL.var\"#45#46\"{REPL.LineEditREPL, Pair{Any, Bool}, Bool, Bool})(io::Any)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:275\n│     [12] with_repl_linfo(f::Any, repl::REPL.LineEditREPL)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:508\n│     [13] print_response(repl::REPL.AbstractREPL, response::Any, show_value::Bool, have_color::Bool)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:273\n│     [14] (::REPL.var\"#do_respond#66\"{Bool, Bool, REPL.var\"#77#87\"{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:844\n│     [15] #invokelatest#2\n│        @ ./essentials.jl:716 [inlined]\n│     [16] invokelatest\n│        @ ./essentials.jl:714 [inlined]\n│     [17] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState)\n│        @ REPL.LineEdit /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493\n│     [18] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef)\n│        @ REPL /nix/store/qmlbjq46nhn1v08nnb23y2myrvra8hm7-julia-bin-1.7.1/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1230\n│     [19] (::REPL.var\"#49#54\"{REPL.LineEditREPL, REPL.REPLBackendRef})()\n│        @ REPL ./task.jl:423\n└ @ Base errorshow.jl:320\n\nStacktrace:\n [1] myfunc2(::WhereTraits.InternalState.TraitsDisambiguationSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a1::Vector{Int64}, ::<ARGS|TYPEVARS>, T1::Type, ::<TYPEVARS|TRAITS>, 'trait_1_Base.IteratorSize(a1)'::Base.HasShape{1}; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Main ./none:0\n [2] myfunc2(::WhereTraits.InternalState.TraitsDisambiguationSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a1::Vector{Int64}, ::<ARGS|TYPEVARS>, T1::Type, ::<TYPEVARS|TRAITS>, 'trait_1_Base.IteratorSize(a1)'::Base.HasShape{1})\n   @ Main ./none:0\n [3] #myfunc2#6\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:212 [inlined]\n [4] myfunc2(a1::Vector{Int64}; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ Main ./REPL[13]:0\n [5] myfunc2\n   @ ~/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:211 [inlined]\n [6] myfunc2(a1::Vector{Int64})\n   @ Main ./REPL[13]:0\n [7] top-level scope\n   @ REPL[14]:1","category":"page"},{"location":"details/#Implementation-Details","page":"WhereTraits Details`","title":"Implementation Details","text":"","category":"section"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"The implementations uses only code-rewrite, creating two nested functions out of the one @traits function. The outer function dispatches as normal, the inner function dispatches on the added traits functionality.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"To inspect what is going on it is helpful to turn off the auto_documentation feature by setting","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"WhereTraits.CONFIG.auto_documentation = false","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"After this the macroexpand is simpler to understand","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"@macroexpand @traits foo(a) where {isodd(a)} = (a+1)/2","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"which gives the following code","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"function foo(a1::T1; kwargs...) where T1\n    #= REPL[6]:1 =#\n    #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:211 =#\n    try\n        #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:212 =#\n        (Main).foo(WhereTraits.InternalState.TraitsDisambiguationSingleton(), Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1, a1, <ARGS|TYPEVARS>(), T1, <TYPEVARS|TRAITS>(), (WhereTraits.Utils.BoolTypes.BoolType)(isodd(a1)); kwargs...)\n    catch exc\n        #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:214 =#\n        (WhereTraits.InternalState.isWhereTraitsMethodError)(exc) || rethrow()\n        #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:215 =#\n        throw((WhereTraitsMethodError)(exc))\n    end\nend\nfunction foo(::WhereTraits.InternalState.TraitsDefSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a, ::<ARGS|TYPEVARS>, var\"'T1'\"::Any, ::<TYPEVARS|TRAITS>, var\"'isodd(a1)'\"::Type{<:WhereTraits.Utils.BoolTypes.True})\n    #= REPL[6]:1 =#\n    (a + 1) / 2\nend\nfunction foo(::WhereTraits.InternalState.TraitsDisambiguationSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a1, ::<ARGS|TYPEVARS>, T1, ::<TYPEVARS|TRAITS>, var\"'trait_1_isodd(a1)'\"::Any; kwargs...)\n    (Main).foo(WhereTraits.InternalState.TraitsDefSingleton(), Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1, a1, <ARGS|TYPEVARS>(), T1, <TYPEVARS|TRAITS>(), var\"'trait_1_isodd(a1)'\"; kwargs...)\nend\nnothing\nfunction foo(::WhereTraits.InternalState.TraitsStoreSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1})\n    #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:76 =#\n    #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:77 =#\n    WhereTraits.InternalState.TraitsStore{Tuple{<CURLIES|SIGNATURE|ARGS>, Any}}(WhereTraits.InternalState.DefOuterFunc{Tuple{<CURLIES|SIGNATURE|ARGS>, Any}}(WhereTraits.InternalState.DefOuterFuncFixedPart{Tuple{<CURLIES|SIGNATURE|ARGS>, Any}}(Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1, Main, :foo, Union{Expr, Symbol}[], ExprParsers.Arg_Parsed[EP.Arg_Parsed(name=:a1, type=:T1, default=ExprParsers.NoDefault())], ExprParsers.TypeRange_Parsed[EP.TypeRange_Parsed(lb=Union{}, name=:T1, ub=Any)], [:a1], [:T1]), WhereTraits.InternalState.DefOuterFuncNonFixedPart(Union{Expr, Symbol}[:(isodd(a1))], Dict{Union{Expr, Symbol}, Union{Expr, Symbol}}(:(isodd(a1)) => :((WhereTraits.Utils.BoolTypes.BoolType)(isodd(a1)))))), Dict{WhereTraits.InternalState.DefInnerFuncFixedPart, WhereTraits.InternalState.DefInnerFuncNonFixedPart}(WhereTraits.InternalState.DefInnerFuncFixedPart(Dict(:a1 => :a), Dict{Symbol, Symbol}(), Dict{Union{Expr, Symbol}, Union{Expr, Symbol}}(:(isodd(a1)) => :(::Type{<:WhereTraits.Utils.BoolTypes.True}))) => WhereTraits.InternalState.DefInnerFuncNonFixedPart(Main, Expr[], quote\n        #= REPL[6]:1 =#\n        (a + 1) / 2\n    end, :((foo(a) where isodd(a)) = begin\n        #= REPL[6]:1 =#\n        (a + 1) / 2\n    end))), WhereTraits.InternalState.DefDisambiguation({1, 0} directed Int64 metagraph with Float64 weights defined by :weight (default weight 1.0)))\nend\nnothing","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"It is actually easy to understand on a high level:","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"The first function function foo(a1::T1; kwargs...) where T1 is the so called \"outer\" function which does all the normal standard Julia dispatch. It is the necessary initial entry point in order to then perform a subsequent call to further dispatch on traits.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"In the function body, within a try-catch, you see that this outer function extracts extra information according to the extended where-syntax. Lets go through the arguments one by one","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"WhereTraits.InternalState.TraitsDisambiguationSingleton() is a helper type indicating that this is a call to the traits disambiguation layer\nTuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1 is the complete function signature of the outer function, with an additional helper <CURLIES|SIGNATURE|ARGS>, which is actually a WhereTraits.Parsing.Normalize._BetweenCurliesAndArgs to deal with TypeParameters of UnionAll types (whereupon which you can also define function calls and hence @traits)\na1 is the first actual argument (after this a2, a3 and etc. could follow in principle)\n<ARGS|TYPEVARS>() is actually a WhereTraits.InternalState.ArgsHelpers_BetweenArgsAndTypeVars(), which is again a helper type to distinguish args from typevariables\nT1 is a type parameter (again here T2, T3, etc. would follow if there are more typeparameters)\n<TYPEVARS|TRAITS>() is actually a WhereTraits.InternalState.ArgsHelpers_BetweenTypeVarsAndTraits(), which is another helper, now separating the traits definitions\n(WhereTraits.Utils.BoolTypes.BoolType)(isodd(a1)) here comes our first actual trait definition (if you define more traits, they would follow here), it is a bool definition and uses the special function BoolType to bring bool values to BoolTypes.\n; kwargs... at last all kwargs are just passed through (dispatch on kwargs is not yet supported)","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"All these arguments are finally passed on to the inner function, which is defined next. (For completeness, there is an intermediate disambiguation layer, which is sitting between outer function and inner function. It will be described shortly after.)","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"The second function is this inner function function foo(::WhereTraits.InternalState.TraitsDefSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a, ::<ARGS|TYPEVARS>, var\"'T1'\"::Any, ::<TYPEVARS|TRAITS>, var\"'isodd(a1)'\"::Type{<:WhereTraits.Utils.BoolTypes.True}).","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Here we define the actual full traits dispatch which was just called in the outer function (we ignore the disambiguation layer for now). Let's again go through each single argument:","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"::WhereTraits.InternalState.TraitsDefSingleton dispatches on the singleton type for an inner-function-definition.\n::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1} dispatches on the signature of the outer function, again adding support for types with Type-parameters which is why you see this extra type <CURLIES|SIGNATURE|ARGS> (which is actually a WhereTraits.Syntax.Parsing.Normalize._BetweenCurliesAndArgs). If you would have dispatch for say function MyType{Int, Bool}(a::Any, b::Any) this would look like ::Type{Tuple{Int, Bool, <CURLIES|SIGNATURE|ARGS>, T1, T2} where {T1, T2}} respectively\na is just the standard argument, which was of type Any.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Hereafter, other arguments would follow.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"::<ARGS|TYPEVARS> (which is actually a ::WhereTraits.InternalState.ArgsHelper_BetweenArgsAndTypeVars) is again a helper for dispatch separation\nvar\"'T1'\"::Any corresponds to the normal standard TypeParameter, here of type Any.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"It was renamed into `var\"'T1'\"`, because it is actually nowhere used in the function body. If you would have used the TypeVariable `T1`, it is named plainly `T1`.\nThis was implemented because the syntax actually may have to add extra typeparameters, which then for sure are not used by the code. We distinguish used/unused typeparameters for better debugging/inspecting.\n\nHereafter, other standard type parameters would follow.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"::<TYPEVARS|TRAITS> (actually ::WhereTraits.InternalState.ArgsHelper_BetweenTypeVarsAndTraits) is the last helper for dispatch separation\nvar\"'isodd(a1)'\"::Type{<:WhereTraits.Utils.BoolTypes.True} is our extended where-dispatch for Bool function\nAs the argument was wrapped into BoolTypes.BoolType, we can now dispatch on BoolTypes.True. The name is extra descriptive and refers to the precise function call which happens in the outer function. This can be helpful for debugging and inspecting.\nThis function does not define any keyword arguments.\nThe third function is the disambiguation, which sits between outer function and inner function. In our case it only forwards the arguments to the inner function, but in general this layer implements the functionality of @traits_order. \nThe last complex looking function is function foo(::WhereTraits.InternalState.TraitsStoreSingleton). Concretely, it defines the hidden state which is needed to correctly construct the outer and inner functions required to realise the extended dispatch of @traits. You don't have to understand it, still you hopefully get the feeling that everything is there.\nFinally there is nothing in order to prevent printing possibly confusing internal details.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"If you try @macroexpand @traits foo(a) where {!isodd(a)} = a/2 instead, you will see that it is very similar, but dispatching on ::BoolTypes.False instead. This is part of the special support for bool function.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Also try @macroexpand @traits foo(a) where {iseven(a)} = a/2 and see what the syntax does differently.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Now execute","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"@traits foo(a) where {isodd(a)} = (a+1)/2","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"and repeat inspecting @macroexpand @traits foo(a) where {!isodd(a)} = a/2 vs @macroexpand @traits foo(a) where {iseven(a)} = a/2.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Also try inspecting methods with other outerfunctions, like @macroexpand @traits foo(a, b) = a + b. You will start appreciating the hidden complexity behind the @traits syntax.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"While the syntax mapping to an outerfunction and respective innerfunctions feels very intuitive, the needed implementation is surprisingly complicated. Luckily, all this is encapsulated nicely in the @traits macro. Enjoy!","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"If you ever are curious what the whole implementation of your @traits function is, there is a helper macro @traits_show_implementation. For instance if you finally defined","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"@traits foo(a) where {isodd(a)} = (a+1)/2\n@traits foo(a) where {!isodd(a)} = a/2","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"@traits_show_implementation will give you the full implementation, omitting the internal state.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia> @traits_show_implementation foo\n  Outer function for signature Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1\n\n  function foo(a1::T1; kwargs...) where T1\n      #= REPL[9]:1 =#\n      begin\n          #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:211 =#\n          try\n              #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:212 =#\n              (Main).foo(WhereTraits.InternalState.TraitsDisambiguationSingleton(), Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1, a1, <ARGS|TYPEVARS>(), T1, <TYPEVARS|TRAITS>(), (WhereTraits.Utils.BoolTypes.BoolType)(isodd(a1)); kwargs...)\n          catch exc\n              #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:214 =#\n              (WhereTraits.InternalState.isWhereTraitsMethodError)(exc) || rethrow()\n              #= /home/ssahm/.julia/dev/WhereTraits/src/Syntax/Rendering.jl:215 =#\n              throw((WhereTraitsMethodError)(exc))\n          end\n      end\n  end)\n\n    •  • •\n\n  Inner functions for signature Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1\n\n  function foo(::WhereTraits.InternalState.TraitsDefSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a, ::<ARGS|TYPEVARS>, var\"'T1'\"::Any, ::<TYPEVARS|TRAITS>, var\"'isodd(a1)'\"::Type{<:WhereTraits.Utils.BoolTypes.True})\n      #= REPL[7]:1 =#\n      (a + 1) / 2\n  end\n\n    •  • •\n\n  function foo(::WhereTraits.InternalState.TraitsDefSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a, ::<ARGS|TYPEVARS>, var\"'T1'\"::Any, ::<TYPEVARS|TRAITS>, var\"'isodd(a1)'\"::Type{<:WhereTraits.Utils.BoolTypes.False})\n      #= REPL[8]:1 =#\n      a / 2\n  end\n\n    •  • •\n\n    •  • •\n\n  Disambiguation functions for signature Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1\n\n  Base.delete_method(foo(::WhereTraits.InternalState.TraitsDisambiguationSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a1, ::<ARGS|TYPEVARS>, T1, ::<TYPEVARS|TRAITS>, var\"'trait_1_isodd(a1)'\"; kwargs...) in Main)\n\n    •  • •\n\n  function foo(::WhereTraits.InternalState.TraitsDisambiguationSingleton, ::Type{Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1}, a1, ::<ARGS|TYPEVARS>, T1, ::<TYPEVARS|TRAITS>, var\"'trait_1_isodd(a1)'\"::Any; kwargs...)\n      (Main).foo(WhereTraits.InternalState.TraitsDefSingleton(), Tuple{<CURLIES|SIGNATURE|ARGS>, T1} where T1, a1, <ARGS|TYPEVARS>(), T1, <TYPEVARS|TRAITS>(), var\"'trait_1_isodd(a1)'\"; kwargs...)\n  end\n\n    •  • •\n\n  ──────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"details/#Performance-Comparison-with-[mauro3/SimpleTraits.jl](https://github.com/mauro3/SimpleTraits.jl)","page":"WhereTraits Details`","title":"Performance + Comparison with mauro3/SimpleTraits.jl","text":"","category":"section"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"For a high-level comparison between WhereTraits.@traits and SimpleTraits.jl see the respective discourse discussion.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"The following examples mirror https://github.com/mauro3/SimpleTraits.jl#details-of-method-dispatch. We start with defining a custom function fn, a custom Trait function isTr and some methods for fn dispatching on the trait.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"isTr(_) = false\n\nfn(x::Integer) = 1\n@traits fn(x::X) where {X<:AbstractFloat, isTr(X)} = 2\n@traits fn(x::AbstractFloat) = 3\n\nfn(Float32(5)) # 3; dispatch through traits, but isTr not yet defined, hence using default case\n\nisTr(::Type{Float32}) = true\nisTr(::Type{Int}) = true\n\nfn(5) # 1; dispatch only happens on the type\nfn(Float32(5)) # 2; dispatch through traits\nfn(Float64(5)) # 3; default dispatch through traits\n\n\nisTr2(_) = false\nisTr2(::Type{Float16}) = true\n@traits fn(x::X) where {X <: AbstractFloat, isTr2(X)} = 4\n\nfn(Float16(5)) # 4; dispatch through traits\nfn(Float32(5)) # 2; NO MethodError; nothing is overwritten, everything works like you would hope for","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"Finally the performance test: Julia is indeed inferring the very same native code.","category":"page"},{"location":"details/","page":"WhereTraits Details`","title":"WhereTraits Details`","text":"julia> @code_native fn(5)\n    .section    __TEXT,__text,regular,pure_instructions\n; ┌ @ none:1 within `fn'\n    movl    $1, %eax\n    retq\n    nopw    %cs:(%rax,%rax)\n; └\njulia> @code_native fn(Float16(5))\n    .section    __TEXT,__text,regular,pure_instructions\n; ┌ @ none:1 within `fn'\n    movl    $4, %eax\n    retq\n    nopw    %cs:(%rax,%rax)\n; └","category":"page"},{"location":"usage/#WhereTraits-Usage","page":"WhereTraits Usage`","title":"WhereTraits Usage","text":"","category":"section"},{"location":"usage/#Usage-@traits","page":"WhereTraits Usage`","title":"Usage @traits","text":"","category":"section"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"@traits supports the following three extensions to Julia's where-syntax:","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"dispatch on functions returning Bool","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"@traits f(a) where {isodd(a)} = (a+1)/2\n@traits f(a) where {!isodd(a)} = a/2\nf(4) # 2.0\nf(5) # 3.0","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"dispatch on functions returning anything","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"@traits g(a) where {Base.IteratorSize(a)::Base.HasShape} = 43\n@traits g(a) = 1\ng([1,2,3]) # 43\ng(Iterators.repeated(1)) # 1","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"dispatch on upperbounds on functions returning Types","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"@traits h(a) where {eltype(a) <: Number} = true\n@traits h(a) = false\nh([1.0]) # true\nh([\"\"]) # false","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"And all this works with arbitrary many where expressions and creates optimal code where possible via standard Julia compiler.","category":"page"},{"location":"usage/#Usage-@traits_order-Resolving-Ambiguities","page":"WhereTraits Usage`","title":"Usage @traits_order - Resolving Ambiguities","text":"","category":"section"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"WhereTraits comes with special support for resolving ambiguities among traits dispatch. ","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Under the hood @traits uses normal function dispatch to acchieve the speed and flexibility, however, julia function dispatch can lead to disambiguities. With traits these can easily happen if someone defines @traits for the same standard dispatch but using different traits. Let's take a look how this looks like","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"using WhereTraits\n# let's say someone defined this version\n@traits conflict(a) where {eltype(a) <: Number} = \"eltype wins\"\n# and another this one\n@traits conflict(a) where {Base.IteratorSize(a) :: Base.HasShape} = \"IteratorSize wins\"","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"You can still use these traits definition as long as there is no ambiguity.","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"julia> conflict(Iterators.countfrom(42))\n\"eltype wins\"\n\njulia> conflict([\"hello\", \"world\"])\n\"IteratorSize wins\"","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"If you use something ambiguous, e.g. a Vector of Numbers, you get a proper ambiguity error, stating what you can do in order to fix it.","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"julia> conflict([1,2,3,4])\nERROR: Disambiguity found. Please specify an ordering between traits, like the following.\n\n    @traits_order (Main).conflict(a1::T1) where T1 begin\n        eltype(a1)\n        Base.IteratorSize(a1)\n    end\n\nStacktrace:\n[...]","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"What is needed in order to resolve the ambiguity is an order between the traits. This can be defined with @traits_order, which takes the respective function signature followed by a begin-end block of ordered traits (most dominant one should be at the top).","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Hence just executing the example @traits_order will make eltype be the winning trait.","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"@traits_order (Main).conflict(a1::T1) where T1 begin\n    eltype(a1)\n    Base.IteratorSize(a1)\nend","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Let's take a look that everything is resolved","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"julia> conflict([1,2,3,4])\n\"eltype wins\"","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Alternatively to the @traits_order you can always define your own custom resolution","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"@traits function conflict(a) where {eltype(a) <: Number, Base.IteratorSize(a) :: Base.HasShape}\n    \"custom implementation\"\nend","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"which immediately will resolve correctly","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"julia> conflict([1,2,3,4])\n\"custom implementation\"","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"For more details, take a look at the documentation.","category":"page"},{"location":"usage/#Limitations","page":"WhereTraits Usage`","title":"Limitations","text":"","category":"section"},{"location":"usage/#Optimal-Code","page":"WhereTraits Usage`","title":"Optimal Code","text":"","category":"section"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Warning: While the dispatch works for dynamic functions, it will only be able to create optimal code if your traits function supports proper type-inference. E.g. you can use Base.isempty, however type-inference cannot see whether it will return true or false by static inspection. Hence it will use slower dynamic code.","category":"page"},{"location":"usage/#Keyword-arguments","page":"WhereTraits Usage`","title":"Keyword arguments","text":"","category":"section"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Keyword arguments are at the moment not support for WhereTraits dispatch. They are just passed through.","category":"page"},{"location":"usage/#Symbol-Level","page":"WhereTraits Usage`","title":"Symbol Level","text":"","category":"section"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"The extended where syntax is currently implemented on symbol level, which is why traits functions like Base.IteratorSize and the non-qualified IteratorSize (assuming you imported import Base: IteratorSize) are treated as two different functions, despite being the same. So for now try to only use the one style or the other.","category":"page"},{"location":"usage/#Top-Level-Only","page":"WhereTraits Usage`","title":"Top Level Only","text":"","category":"section"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Currently only top-level functions are supported, as the syntax stores and needs information about previous function definitions, which it stores globally. If macros would get informed about whether they are defined within another function, WhereTraits could also support innerfunctions. ","category":"page"},{"location":"usage/#Test-package","page":"WhereTraits Usage`","title":"Test package","text":"","category":"section"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"The @traits macro currently does not work well within the Test.@testset macro. Usually you won't encounter this, as standard dispatch is probably enough for your tests.","category":"page"},{"location":"usage/","page":"WhereTraits Usage`","title":"WhereTraits Usage`","text":"Nevertheless there is a workaround. WhereTraits.jl exports a @traits_test macro variant which works better, but still might have cases where it fails. This needs to be investigated further, and maybe needs a change on Test.@testset.","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#WhereTraits","page":"Library","title":"WhereTraits","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = WhereTraits","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@traits\n@traits_order","category":"page"},{"location":"library/#WhereTraits.Syntax.@traits","page":"Library","title":"WhereTraits.Syntax.@traits","text":"@traits f(a, b) where {!isempty(a), !isempty(b)} = (a[1], b[1])\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.Syntax.@traits_order","page":"Library","title":"WhereTraits.Syntax.@traits_order","text":"@traits_order AnotherModule.anotherfunc(a::T, b::T) where {T} begin     isempty(a)     isempty(b) end\n\n\n\n\n\n","category":"macro"},{"location":"library/","page":"Library","title":"Library","text":"There are also some helpers:","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@traits_show_implementation\n@traits_test","category":"page"},{"location":"library/#WhereTraits.ExtraHelpers.@traits_show_implementation","page":"Library","title":"WhereTraits.ExtraHelpers.@traits_show_implementation","text":"@traits_show_implementation mytraitsenabled_function\n\nRender a whole TraitsStore. To get an easy fealing of what is going on and inspect errors.\n\nFor debugging purposes only.\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.ExtraHelpers.@traits_test","page":"Library","title":"WhereTraits.ExtraHelpers.@traits_test","text":"like @traits, and works within Test.@testset, but cannot be doc-stringed\n\nneeded because of https://github.com/JuliaLang/julia/issues/34263\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.BasicTraits","page":"Library","title":"WhereTraits.BasicTraits","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = WhereTraits.BasicTraits","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@overwrite_Base\niscallable\nisiterable\nisimmutable\nismutable\nisconcretetype\nisbitstype","category":"page"},{"location":"library/#WhereTraits.BasicTraits.@overwrite_Base","page":"Library","title":"WhereTraits.BasicTraits.@overwrite_Base","text":"WhereTraits.BasicTraits.@overwrite_Base\n\nOverloading functions already defined in base, so that they work similar to Base.eltype in that they are best defined on Types, with a fallback from values which just grabs the type of the value and tries it again.\n\nThe following functions are currently over-defined:\n\nisimmutable\nismutable\nisbitstype\nisconcretetype\n\nIn addition, also using WhereTraits.BasicTraits is run.\n\n\n\n\n\n","category":"macro"},{"location":"library/#WhereTraits.BasicTraits.iscallable","page":"Library","title":"WhereTraits.BasicTraits.iscallable","text":"callable(T) -> Bool\n\nChecks whether the call-syntax is defined for the given Type. For convenience iscallable(value) = iscallable(typeof(value))\n\nExamples\n\njulia> using WhereTraits; WhereTraits.BasicTraits.@overwrite_Base\n\njulia> iscallable(typeof(+))\ntrue\n\njulia> iscallable(+)\ntrue\n\njulia> iscallable(Some)\nfalse\n\njulia> iscallable(typeof(Some))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isiterable","page":"Library","title":"WhereTraits.BasicTraits.isiterable","text":"isiterable(T) -> Bool\n\nTest if type T is an iterable collection type or not, that is whether it has an iterate method or not.\n\nWhen given a value instead of a Type, it fallbacks to use typeof(value).\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isimmutable","page":"Library","title":"WhereTraits.BasicTraits.isimmutable","text":"isimmutable(v) -> Bool\n\nReturn true iff value v is immutable.  Note that this function works on Types instead of values (oppositely to Base.isimmutable). When applied to a value, a default clause will match on its type instead.\n\nExamples\n\njulia> using WhereTraits; WhereTraits.BasicTraits.@overwrite_Base\n\njulia> isimmutable(1)\ntrue\n\njulia> isimmutable([1,2])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.ismutable","page":"Library","title":"WhereTraits.BasicTraits.ismutable","text":"ismutable(v) -> Bool\n\nReturn true iff value v is mutable.  Note that this function works on Types instead of values (oppositely to Base.isimmutable). When applied to a value, a default clause will match on its type instead.\n\nExamples\n\njulia> using WhereTraits; WhereTraits.BasicTraits.@overwrite_Base\n\njulia> ismutable(1)\nfalse\n\njulia> ismutable([1,2])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isconcretetype","page":"Library","title":"WhereTraits.BasicTraits.isconcretetype","text":"isconcretetype(T)\n\nDetermine whether type T is a concrete type, meaning it could have direct instances (values x such that typeof(x) === T).\n\nFor convenience isconcretetype(value) = isconcretetype(typeof(value))\n\nExamples\n\njulia> using WhereTraits; WhereTraits.BasicTraits.@overwrite_Base\n\njulia> isconcretetype(Complex)\nfalse\n\njulia> isconcretetype(Complex{Float32})\ntrue\n\njulia> isconcretetype(Vector{Complex})\ntrue\n\njulia> isconcretetype(Vector{Complex{Float32}})\ntrue\n\njulia> isconcretetype(Union{})\nfalse\n\njulia> isconcretetype(Union{Int,String})\nfalse\n\njulia> isconcretetype([1,2,3])\ntrue\n\njulia> isconcretetype(\"hi\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/#WhereTraits.BasicTraits.isbitstype","page":"Library","title":"WhereTraits.BasicTraits.isbitstype","text":"isbitstype(T)\n\nReturn true if type T is a \"plain data\" type, meaning it is immutable and contains no references to other values, only primitive types and other isbitstype types. Typical examples are numeric types such as UInt8, Float64, and Complex{Float64}. This category of types is significant since they are valid as type parameters, may not track isdefined / isassigned status, and have a defined layout that is compatible with C.\n\nFor convenience isbitstype(value) = isbitstype(typeof(value))\n\nExamples\n\njulia> using WhereTraits; WhereTraits.BasicTraits.@overwrite_Base\n\njulia> isbitstype(Complex{Float64})\ntrue\n\njulia> isbitstype(Complex)\nfalse\n\njulia> isbitstype(1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"basictraits/#WhereTraits.BasicTraits","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"","category":"section"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"For anology with SimpleTraits.jl, this package comes with standard traits definitions ismutable, isimmutable, isiterable, iscallable, isbitstype, isconcretetype. They mostly just wrap respective standard definitions in Base, with the added benefit, that they behave similarly to Base.eltype in that they have the convenience fallback ismutable(value) = ismutable(typeof(value)).","category":"page"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"You can use them by executing the following","category":"page"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"using WhereTraits\nusing WhereTraits.BasicTraits\nWhereTraits.BasicTraits.@overwrite_Base\n\nismutable(1)  # false\nismutable(\"string\")  # true\nismutable(String)  # true","category":"page"},{"location":"basictraits/","page":"WhereTraits.BasicTraits","title":"WhereTraits.BasicTraits","text":"Please consult the file test/BasicTraits.jl for more examples.","category":"page"},{"location":"#WhereTraits.jl","page":"Home","title":"WhereTraits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to WhereTraits.jl. This package exports one powerful macro @traits with which you can extend Julia's where syntax in order to support traits definitions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, WhereTraits comes with a standardized way how to resolve ambiguities among traits, by defining an order among the traits with @traits_order.","category":"page"},{"location":"#Installation-and-Import","page":"Home","title":"Installation & Import","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add WhereTraits\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then use this package by loading","category":"page"},{"location":"","page":"Home","title":"Home","text":"using WhereTraits","category":"page"},{"location":"","page":"Home","title":"Home","text":"which brings @traits into your namespace, and in addition also @traits_order for resolving ambiguities.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"usage.md\", \"details.md\", \"basictraits.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"},{"location":"isdef/#Dispatch-on-whether-functions-are-defined-using-[IsDef.jl](https://github.com/schlichtanders/IsDef.jl)","page":"Dispatch on whether functions are defined - using IsDef.jl","title":"Dispatch on whether functions are defined - using IsDef.jl","text":"","category":"section"},{"location":"isdef/","page":"Dispatch on whether functions are defined - using IsDef.jl","title":"Dispatch on whether functions are defined - using IsDef.jl","text":"You want to dispatch on whether a function is defined or not? I guess this is a standard scenario and hence I tried to support it, and extracted it into another package.","category":"page"},{"location":"isdef/","page":"Dispatch on whether functions are defined - using IsDef.jl","title":"Dispatch on whether functions are defined - using IsDef.jl","text":"IsDef.jl exports two functions isdef and Out with which you can dispatch on whether functions are defined or not. (IsDef.jl is a sub-dependency of WhereTraits.jl, so you should already have it installed). With IsDef.isdef/IsDef.Out and WhereTraits.@traits we can define typesafe dispatch like follows:","category":"page"},{"location":"isdef/","page":"Dispatch on whether functions are defined - using IsDef.jl","title":"Dispatch on whether functions are defined - using IsDef.jl","text":"using WhereTraits\nusing IsDef\nusing Test\n\nstruct MyError <: Exception\n  msg::AbstractString\nend\nMyError() = MyError(\"\")\n\n@traits typesafe_call(f, a::T) where {T, isdef(f, T)} = f(a)\n# note that you can also use isdef on args directly, like you can use eltype on args\n# however this will be recognized as a different traitfunction compared to isdef(f, T)\n# which can lead to ambiguous overloadings. Just good to keep in mind\n@traits typesafe_call(f, a) where {!isdef(f, a)} = throw(MyError(\"given function cannot work with given arg\"))\n@code_llvm typesafe_call(x -> x+2, 4)  # looks really good\n\n@test typesafe_call(x -> x+2, 4) == 6\n@test_throws MyError typesafe_call(x -> x+2, \"string\")\n\n\n@traits typesafe_out(f, a) where {Out(f, a) <: Number} = f(a) + 6\n@traits typesafe_out(f, a) where {Out(f, a) <: String} = \"yeah $(f(a))!\"\n@traits typesafe_out(f, a) = throw(MyError(\"no match\"))\n\n@test typesafe_out(x -> 3x, 1) == 9\n@test typesafe_out(x -> \"$x $x\", 1) == \"yeah 1 1!\"\n@test_throws MyError typesafe_out(x -> convert(Vector, x), 1)\n\n\n# more complex case with dependencies among functions\n@traits function typesafe_aggregate(a::Vector{A}, introduce, combine) where\n    {A, isdef(introduce, A), isdef(combine, Out(introduce, A), Out(introduce, A))}\n\n  reduce(combine, introduce.(a))\nend\n@traits typesafe_aggregate(a::Vector, introduce, combine) = throw(MyError(\"TypeError\"))\n\n@test typesafe_aggregate([\"this\",\"is\",\"a\",\"test\"], length, +) == 11\n@test typesafe_aggregate([\"this\",\"is\",\"a\",\"test\"], length, *) == 32\n@test typesafe_aggregate([\"this\",\"is\",\"a\",\"test\"], x -> \"$x \", *) == \"this is a test \"\n@test_throws MyError typesafe_aggregate([\"this\",\"is\",\"a\", \"test\"], x->x, +)","category":"page"},{"location":"isdef/","page":"Dispatch on whether functions are defined - using IsDef.jl","title":"Dispatch on whether functions are defined - using IsDef.jl","text":"This is very powerful. Be warned that IsDef has limitations currently because julia type-inference has limitations. Luckily the type-inference is already very good with concrete-types, which is what we need for dispatch.","category":"page"}]
}
